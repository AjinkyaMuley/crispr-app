import type { Document } from '../bson';
import { Collection } from '../collection';
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 84c787a2e896c0e7a46e04aae83d200a1242e9bc
import { MongoServerError } from '../error';
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { type Callback, checkCollectionName } from '../utils';
import type { CommandOperationOptions } from './command';
import { Aspect, defineAspects } from './operation';
import { RunAdminCommandOperation } from './run_command';
<<<<<<< HEAD
=======
=======
import type { Server } from '../sdam/server';
import type { ClientSession } from '../sessions';
import { MongoDBNamespace } from '../utils';
import { CommandOperation, type CommandOperationOptions } from './command';
import { Aspect, defineAspects } from './operation';
>>>>>>> 606e41d43ceed91f179614d13298418977dd016f
>>>>>>> 84c787a2e896c0e7a46e04aae83d200a1242e9bc

/** @public */
export interface RenameOptions extends CommandOperationOptions {
  /** Drop the target name collection if it previously exists. */
  dropTarget?: boolean;
  /** Unclear */
  new_collection?: boolean;
}

/** @internal */
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 84c787a2e896c0e7a46e04aae83d200a1242e9bc
export class RenameOperation extends RunAdminCommandOperation {
  override options: RenameOptions;
  collection: Collection;
  newName: string;

  constructor(collection: Collection, newName: string, options: RenameOptions) {
    // Check the collection name
    checkCollectionName(newName);

    // Build the command
    const renameCollection = collection.namespace;
    const toCollection = collection.s.namespace.withCollection(newName).toString();
    const dropTarget = typeof options.dropTarget === 'boolean' ? options.dropTarget : false;
    const cmd = { renameCollection: renameCollection, to: toCollection, dropTarget: dropTarget };

    super(collection, cmd, options);
    this.options = options;
    this.collection = collection;
    this.newName = newName;
  }

  override executeCallback(
    server: Server,
    session: ClientSession | undefined,
    callback: Callback<Collection>
  ): void {
    const coll = this.collection;

    super.executeCallback(server, session, (err, doc) => {
      if (err) return callback(err);
      // We have an error
      if (doc?.errmsg) {
        return callback(new MongoServerError(doc));
      }

      let newColl: Collection<Document>;
      try {
        newColl = new Collection(coll.s.db, this.newName, coll.s.options);
      } catch (err) {
        return callback(err);
      }

      return callback(undefined, newColl);
    });
<<<<<<< HEAD
=======
=======
export class RenameOperation extends CommandOperation<Document> {
  constructor(
    public collection: Collection,
    public newName: string,
    public override options: RenameOptions
  ) {
    super(collection, options);
    this.ns = new MongoDBNamespace('admin', '$cmd');
  }

  override async execute(server: Server, session: ClientSession | undefined): Promise<Collection> {
    // Build the command
    const renameCollection = this.collection.namespace;
    const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
    const dropTarget =
      typeof this.options.dropTarget === 'boolean' ? this.options.dropTarget : false;

    const command = {
      renameCollection: renameCollection,
      to: toCollection,
      dropTarget: dropTarget
    };

    await super.executeCommand(server, session, command);
    return new Collection(this.collection.s.db, this.newName, this.collection.s.options);
>>>>>>> 606e41d43ceed91f179614d13298418977dd016f
>>>>>>> 84c787a2e896c0e7a46e04aae83d200a1242e9bc
  }
}

defineAspects(RenameOperation, [Aspect.WRITE_OPERATION]);
